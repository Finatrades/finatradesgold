You are a Senior Security Engineer + QA Automation Lead. Your job is to run an end-to-end “auto security + abuse + workflow” test on THIS WHOLE CODEBASE and produce a single consolidated report.

GOAL
1) Discover and exploit (safely) any security weakness across UI, API, DB, auth, admin, payments/ledger flows, file uploads, and integrations.
2) Validate business logic + reconciliation rules (wallet balances, ledger, certificates, orders, KYC gates).
3) Generate a clear PASS/FAIL report with proof, risk, and exact fixes.

STRICT RULES
- Do NOT delete production data. Use only local/dev environment and seed mock data.
- Prefer automated scripts + test harness. Where manual steps are needed, document them.
- Every finding must include: reproduction steps, affected endpoint/file, severity (Critical/High/Med/Low), and a concrete fix patch or code snippet.
- Log all requests/responses (redact secrets). Save artifacts to /reports.

STEP 0 — PROJECT DISCOVERY (AUTO)
- Detect stack: framework, language, ORM, auth, session, DB, payment providers, storage (S3), email/SMS, admin panel routes.
- Map folders: src/, app/, server/, api/, routes/, middleware/, db/, migrations/, tests/, config.
- Identify environment variables referenced in code; list missing/unsafe ones (do not print secret values).

DELIVERABLE FOLDERS (CREATE)
- /reports/security_report.md
- /reports/test_evidence/ (screenshots/logs)
- /reports/api_map.json
- /reports/threat_model.md
- /reports/fix_patches/ (diff patches)

STEP 1 — BUILD & RUN
1) Install deps, run lint, run typecheck.
2) Start backend + frontend locally with test config.
3) Confirm health endpoints and admin/user apps load.
4) If Docker exists, use it. If not, run standard dev scripts.

STEP 2 — DATA SEEDING (MOCK USERS + ROLES)
Create seed script to create at least:
- 10 Personal users (KYC: unverified, pending, verified)
- 10 Business users (KYB: unverified, pending, verified)
- 3 Admin roles: superadmin, finance_admin, support_admin
- 5 Merchants / vendors (if e-commerce exists)
- 200 mock transactions across all flows
- 50 certificates / vault ledger entries (if applicable)
- 20 trade cases (if applicable)
Store credentials in /reports/test_evidence/test_accounts.json

STEP 3 — AUTOMATED TEST HARNESS (MUST IMPLEMENT)
Implement and run an automated security test harness that covers:
A) AUTH & SESSION
- Signup/login brute force protections
- Password policy validation
- Email verification / OTP bypass attempts
- Session fixation, session expiry, refresh token misuse
- JWT validation: alg=none, kid injection, token replay, missing audience/issuer
- Cookie flags: HttpOnly/Secure/SameSite, CSRF defenses

B) AUTHORIZATION / RBAC (USER vs BUSINESS vs ADMIN)
- Try horizontal privilege escalation (access another user’s wallet/transactions/certificates)
- Try vertical escalation (user -> admin endpoints)
- Test BOLA/IDOR on every object: /users/:id, /wallets/:id, /tx/:id, /orders/:id, /kyc/:id, /cert/:id, /trade/:id
- Ensure admin actions require admin session AND correct role

C) INPUT VALIDATION / INJECTION (API + UI)
- SQLi / NoSQL injection payloads in query/body/headers
- Command injection checks on any file/exec usage
- XSS (stored/reflected/DOM) on all user profile fields, notes, narrations, admin remarks
- CSRF tests for state-changing routes
- Mass assignment tests on PATCH/PUT endpoints

D) RATE LIMIT / ABUSE / DOS (SAFE)
- Identify rate limits for login, OTP, password reset, transfers, withdrawals, uploads
- Attempt safe burst traffic and confirm throttling + lockouts

E) FILE UPLOAD SECURITY (RECEIPTS / KYC / DOCUMENTS)
- Upload: oversized files, wrong MIME, polyglot, double extensions, SVG script, PDF JS, zip bombs (safe simulation)
- Verify storage ACLs (private), signed URLs expiry, path traversal
- Ensure virus scanning hook or at least content-type sniffing + size limits

F) BUSINESS LOGIC (FINTECH CRITICAL)
- Deposit/withdraw double submission (race condition)
- Transfer negative/zero/very large values
- Replay transaction requests
- Currency/precision rounding errors
- Ensure ledger is source-of-truth and balances reconcile:
  balance == sum(ledger entries) within rounding tolerance
- Ensure KYC/KYB gates block restricted actions
- Ensure admin approvals are required where expected
- Verify “manual buy gold” or “receipt approval” cannot be forged or self-approved

G) SECURITY HEADERS & FRONTEND
- Check headers: CSP, HSTS, X-Frame-Options/frame-ancestors, X-Content-Type-Options, Referrer-Policy, Permissions-Policy
- Check CORS config (no wildcard with credentials)
- Check secrets in frontend bundles
- Check localStorage token usage risks
- Test clickjacking

H) DEPENDENCIES / SUPPLY CHAIN
- Run dependency audit (npm/pip/etc.) and create SBOM
- Flag high/critical CVEs with upgrade path

I) CLOUD / CONFIG (STATIC ANALYSIS)
- Scan repo for leaked keys, private URLs, debug flags, unsafe CORS, default passwords
- Validate env example files don’t contain real secrets
- Check S3 bucket policies (if present in IaC)
- Ensure logging doesn’t leak PII

STEP 4 — DYNAMIC API TESTING (AUTO DISCOVERY)
- Auto-discover API routes from code + OpenAPI (if any)
- Generate Postman/collection-like runner
- For each route, run:
  - unauth request
  - wrong role request
  - valid role request
  - BOLA/IDOR tests with swapped IDs
  - fuzzing for common payload classes

STEP 5 — UI E2E TESTS (AUTO)
Using Playwright/Cypress (choose what fits stack):
- Full flows:
  - signup -> email verify -> login -> KYC -> deposit -> buy -> transfer -> withdraw
  - business KYB -> trade case -> approvals -> settlement
  - admin approve KYC/KYB -> approve receipt -> adjust ledger (if exists) -> export reports
- Validate dark/light mode UI:
  - contrast, broken layout, missing text, wrong colors, overlap
- Capture screenshots for every major page and attach to /reports/test_evidence/ui/

STEP 6 — CODE FIXES (MANDATORY)
For every Critical/High issue:
- Implement fix in codebase
- Add regression tests
- Provide patch diff files under /reports/fix_patches/
- Re-run the failing test to show PASS evidence

STEP 7 — FINAL REPORT (SINGLE OUTPUT)
Generate /reports/security_report.md containing:
1) Executive summary (what’s safe, what’s risky)
2) Risk table (CVE/issue, severity, impacted modules, status)
3) Detailed findings with reproduction + fixes
4) API map + RBAC matrix
5) Data reconciliation results (balances vs ledger)
6) Evidence links (logs/screenshots)
7) Recommended next steps (SOC2-ready checklist)

NOW START.
- First: print detected stack + run plan.
- Then: implement the scripts/tests.
- Then: run them and write the reports.
- Do not stop until the report files are generated.
