You are a senior application security engineer + code auditor working inside a Finatrades Replit codebase.

Goal:
Perform a FULL codebase security audit to ensure there is NO data leakage, NO secrets exposure, and security is enforced at micro-level across frontend, backend, APIs, DB, logs, storage, and CI/deploy settings.

IMPORTANT:
- Do not do penetration/exploitation. This is a defensive audit + hardening only.
- Do not break existing logic. Make minimal safe patches.
- Produce actionable findings with exact file paths + line numbers + fix commits.
- Assume this is a fintech platform: security > convenience.

PHASE 1 — INVENTORY & RISK MAP (AUTOMATED)
1) Identify stack:
- frameworks, runtime, auth method, DB, storage, payment providers
2) List all entrypoints:
- API routes/controllers
- webhooks
- auth callbacks
- admin endpoints
- file upload endpoints
3) Create a security map:
- where user PII is stored
- where financial data is processed
- where certificates are generated
- where emails/OTPs are handled
- where logs are written

PHASE 2 — SECRETS & LEAKAGE SCAN (MUST DO)
Search entire repo for secrets patterns and leakage:
- keys/tokens: "api_key", "secret", "sk_", "Bearer ", "PRIVATE_KEY", "AWS_", "SENDGRID", "SMTP", "FIREBASE", "SUPABASE", "STRIPE", "NGenius", "BINANCE", "WEBHOOK_SECRET"
- crypto material: "seed", "mnemonic", "private key", "keystore"
- credentials: "password=", "Authorization:", ".env", ".pem", ".p12", ".key"
Check:
- committed secrets in repo
- secrets printed in logs
- secrets exposed to frontend (NEXT_PUBLIC, VITE_, REACT_APP_)
Actions:
- Remove any hardcoded secrets immediately.
- Move to environment variables.
- Add .gitignore rules for sensitive files.
- Add a CI/pre-commit secret scan script (gitleaks-like local scan) if possible.

PHASE 3 — AUTHN/AUTHZ & RBAC (MICRO-LEVEL)
Audit every endpoint and action:
- Ensure authentication is required where appropriate.
- Ensure authorization checks exist server-side (not only UI).
- Validate role checks for admin/ops/compliance/finance routes.
- Verify “horizontal access control”:
  user can ONLY access their own resources (wallets, tx, certificates, KYC).
Checklist:
- endpoints must verify userId ownership for entityId routes
- no IDOR (Insecure Direct Object Reference)
- admin endpoints must be behind RBAC and audit-logged
Actions:
- Add centralized middleware: requireAuth, requireRole, requireOwnership
- Ensure all routes use middleware consistently.

PHASE 4 — INPUT VALIDATION & BUSINESS LOGIC SAFETY
Audit all inputs:
- request bodies, query params, headers, webhooks payloads
- enforce schema validation using Zod/Joi/Yup or existing validator
Rules:
- validate types, ranges, enum values
- money amounts must be decimal-safe (no float rounding issues)
- enforce min/max limits from config
- reject unexpected fields (whitelisting)
Actions:
- Add schema validation for every API route.
- Add consistent error response shape with requestId.

PHASE 5 — XSS/CSRF/CORS/SECURITY HEADERS
Frontend:
- no dangerouslySetInnerHTML unless sanitized
- sanitize any rich text, markdown, HTML templates
Backend:
- set security headers:
  Content-Security-Policy, X-Frame-Options, X-Content-Type-Options, Referrer-Policy, Permissions-Policy
- CSRF protection if cookies/session-based auth
- CORS locked to allowed origins
- cookie flags: HttpOnly, Secure, SameSite
Actions:
- Implement a secure default headers middleware.
- Lock CORS to production + preview origins only.

PHASE 6 — LOGGING & PII REDACTION (NO LEAKAGE)
Audit all logs:
- ensure logs never print:
  passwords, OTPs, auth headers, tokens, card details, bank details, private keys
Implement:
- redaction utility that masks:
  email (e.g., l***l@domain.com), phone, account numbers, IDs
- structured logs with requestId
- separate audit logs (who did what) from system logs (errors)
Actions:
- Replace console.log dumps of req.body/headers with redacted logs.
- Ensure error stack traces are server-only; UI gets safe messages.

PHASE 7 — OTP, EMAIL, PAYMENT SECURITY
OTP:
- never stored in plaintext; store hashed OTP
- expiry + attempt limits + resend cooldown
- OTP is bound to purpose/entity/recipient
Email:
- templates must not leak PII unnecessarily
- ensure "to" address is correct; prevent email injection
Payments:
- never store raw card data
- verify webhooks with signature
- idempotency keys for payment events
Actions:
- Add webhook signature verification (if missing).
- Add idempotency handling for deposits/withdrawals.

PHASE 8 — FILE UPLOADS, CERTIFICATES, STORAGE
Audit file handling:
- allowlist mime types
- size limits
- virus scan hook (optional)
- store outside web root
- signed URLs for downloads
Certificates:
- download endpoints must check ownership/RBAC
- no public predictable URLs
Actions:
- Implement signed download links or auth-gated download with strict checks.

PHASE 9 — DATABASE SECURITY
Audit ORM/SQL usage:
- prevent SQL injection (parameterized queries)
- least privilege DB user in env
- avoid over-broad queries returning extra PII
- ensure soft-deleted records are not accessible
Actions:
- Add query scopes and explicit selects.
- Add indexes for security-relevant lookup to avoid timing leaks.

PHASE 10 — RATE LIMITING & ABUSE PROTECTION
Implement/verify:
- rate limit login, OTP request, password reset, public endpoints
- brute-force protections
- lockout policies
- CAPTCHA only if needed
Actions:
- Add rate limiter middleware (per IP + per user).

PHASE 11 — DEPLOYMENT & CONFIG HARDENING
Check:
- environment variable separation (dev/preview/prod)
- disable debug endpoints in production
- ensure QA_MODE cannot be enabled in prod
- ensure source maps not exposing secrets
- ensure no open admin routes
Actions:
- Add “production guardrails” that fail boot if unsafe flags are enabled.

OUTPUT REQUIRED (MANDATORY)
1) Create SECURITY_REPORT.md with:
- Critical/High/Medium/Low findings
- exact file paths + line numbers
- reproduction steps (safe)
- recommended fix + status (fixed/pending)
2) Implement fixes for all Critical + High immediately.
3) Add automated security checks:
- eslint security rules (where possible)
- dependency audit (npm audit)
- secret scan script
4) Run:
- unit tests
- build
- basic smoke run
and show results.

START NOW:
- Run the secrets scan first.
- Then audit auth/ownership checks on every API route.
- Then fix logging redaction + webhook verification.
