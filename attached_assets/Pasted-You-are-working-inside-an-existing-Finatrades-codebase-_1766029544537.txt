You are working inside an existing Finatrades codebase that already has its own OTP + notification logic.
DO NOT propose a new universal schema. DO NOT replace current logic.
Your job is to ADAPT to the current system and only add what is missing.

OBJECTIVE
1) Make OTP messages informative for BOTH user and admin sides (without leaking secrets).
2) Ensure every OTP + important activity triggers:
   - Email to the correct recipient
   - In-app notification on user side
   - In-app notification on admin side (only when it’s an admin action/approval)
3) Add real logs + audit trail for OTP lifecycle and notification delivery.
4) Keep backward compatibility with existing tables, endpoints, and workflows.

STEP 1 — DISCOVER CURRENT LOGIC (must do first)
Scan the repo and list what already exists (no guessing):
- OTP table/model name and fields
- OTP endpoints/routes and request/response shapes
- Notification table/model (if any) and fields
- Email sending service/provider (SMTP/SendGrid/etc.) or any outbox table
- Existing event/audit log tables
Search keywords:
"otp" "one time" "verification code" "purpose" "audience" "email template"
"notification" "bell" "toast" "outbox" "sendEmail" "mailer" "nodemailer"
"deposit" "withdrawal" "approve" "admin approval"
Return a short map of:
- files
- functions
- data flow

STEP 2 — ADD “PURPOSE CONTEXT” WITHOUT CHANGING THE CORE
Whatever OTP model exists today, extend it minimally by ONE of these safe methods:
Option A) If OTP already has a metadata/json field => store:
   otpContext = { actionType, amountUsd, currency, method, entityType, entityId, userMasked, txId }
Option B) If no metadata field => DO NOT add a big schema.
   Instead, create a small “otp_context” mapping table keyed by otpId OR requestId with only:
   { otpId/requestId, actionType, entityType, entityId, amountUsd, currency, method, createdAt }
Option C) If adding a column is easiest => add ONE column:
   contextJson TEXT/JSON (nullable)
Pick the smallest change compatible with the current DB.

STEP 3 — INFORMATIVE OTP EMAILS (user + admin) USING EXISTING TEMPLATE SYSTEM
Update the email templates/messages only; do not change how OTP is generated.

Rules:
- USER OTP email is only sent to the user who requested/owns the action.
- ADMIN/EMPLOYEE OTP email is only for admin-side actions (admin login, admin approval).
- Never send a user OTP to admins.

User OTP email format:
Subject: "Finatrades OTP — Confirm <Action>"
Body includes:
- OTP code
- Action: e.g., "Confirm Deposit"
- Amount + currency (if applicable)
- Method (BANK/CRYPTO/CARD) if available
- Reference ID / Transaction ID (if available)
- Expiry: "Valid for X minutes"
- Warning: "Do not share this code with anyone."

Admin OTP email format:
Subject: "Admin OTP — Approve <Action>"
Body includes:
- OTP code
- Action: e.g., "Approve Deposit"
- Amount + currency
- User identifier SAFE: masked email (e.g., l***l@finatrades.com) or userId
- Transaction/Case ID
- Expiry and warning

If some fields are missing in current flow, gracefully omit them (do not break).

STEP 4 — IN-APP NOTIFICATIONS (BOTH SIDES) USING CURRENT SYSTEM
Do not invent a new notifications system.
Integrate into existing one:
- When OTP is requested:
  - user gets in-app notification: "OTP sent for <Action> <Amount>"
  - admin gets notification ONLY if admin action requires OTP (approval/login)
- When OTP is verified/failed/expired:
  - log event + show in notification timeline
- When high-value action requires admin approval:
  - create admin notification item: "Approval required: <Action> <Amount> (User masked) (Ref ID)"

STEP 5 — REAL LOGS + AUDIT (minimal change)
Add structured logs around existing OTP functions:
- otp.requested
- otp.sent
- otp.verify.success
- otp.verify.fail (wrong code/expired/too many attempts)
- notification.created
- email.sent or email.queued

Log format (JSON):
{ ts, level, requestId, actorType, actorId/emailMasked, action, entityType, entityId, amountUsd, status, error? }

If an audit table exists, insert there. If not, add minimal audit logging to existing logs only (do not add big new schema unless absolutely required).

STEP 6 — CONNECT TO REAL FLOWS
Wire into existing flows (do not rewrite them):
- Deposit confirm / deposit approval
- Withdrawal confirm / withdrawal approval
- Login OTP (if used)
- Change bank details / beneficiary (if present)

Add “purpose context” at the point the OTP is created so the email + notifications can mention:
- Amount
- Method
- User masked
- Transaction ID

STEP 7 — TESTS (match current stack)
Add tests that assert:
- User OTP email contains correct purpose text (amount/method/txId when present)
- Admin OTP email contains approval context and masked user identifier
- User OTP never sent to admin
- Admin OTP never sent to user
- In-app notifications appear in correct inbox (user vs admin) for the same action
- Logs include requestId and action context

DELIVERABLE
- Keep existing DB + APIs
- Only minimal additions (contextJson or mapping table)
- Updated templates + notifications + logs
- No breaking changes

Start now by mapping current OTP + email + notification files and then implement the minimal “purpose context” extension.
