You are a Senior Performance Engineer + SRE. 
Goal: Execute an end-to-end LOAD + STRESS + SOAK test for my platform using 200,000 realistic users worth of data, and produce a deep report with bottlenecks + fixes.

CONTEXT
- Platform: Web + API (user + admin panels)
- Domain: Digital gold system (wallets, transfers, approvals, admin components)
- Environments: staging first, then production-like (if staging passes)
- Must test: auth, KYC/KYB, dashboard, wallet balances, gold buy/sell, send/receive, payment requests, admin approvals, notifications, reports.
- Must NOT break security: no real PII, use synthetic data.

INPUTS YOU MUST ASK ME TO FILL (if missing, infer best defaults)
1) Base URLs: WEB_BASE_URL, API_BASE_URL
2) Auth method: JWT/cookies/OAuth + login endpoint(s)
3) Key endpoints list (or auto-discover from OpenAPI/Swagger if available)
4) Database type + cache (Postgres/MySQL, Redis, etc.)
5) Rate limits / WAF rules (if any)
6) Target SLOs: p95 latency, error rate, throughput

TASKS
A) Test Plan
1. Identify critical user journeys (top 10) and admin journeys (top 5).
2. Define traffic mix (example default):
   - 45% login/session refresh
   - 20% dashboard + balances
   - 15% transaction history + statements
   - 10% send/receive gold value
   - 5% payment request flow (A requests C; C pays B)
   - 3% buy/sell gold
   - 2% admin approval workflow (first approval then final approval)
3. Define phases:
   - Warm-up: 10 minutes ramp 0 → 5k VU
   - Load: 30 minutes hold at 20k VU
   - Stress: 20 minutes ramp 20k → 60k VU until degradation
   - Spike: 5 minutes jump 10k → 80k VU
   - Soak: 4 hours steady 15k–25k VU
(If 200k concurrent VU is unrealistic for this machine, simulate 200k USERS in dataset, and run max stable VU based on infra; clearly state the limit.)

B) DATA GENERATION (200,000 USERS)
1. Create synthetic dataset:
   - 200k users with realistic distribution:
     - 85% regular users
     - 10% corporate users
     - 5% admin/operator (role-based)
   - Include: user_id, phone/email mock, country, KYC status, wallet_id, starting gold balance, fiat balance (if any), referral code, device type.
2. Seed related entities:
   - 1M wallet ledger entries (mix of credit/debit)
   - 300k transfers (small/medium/large)
   - 50k payment requests
   - 20k buy/sell orders
   - 10k admin approval items with 2-step approvals
   - Notifications: 500k records
3. Create scripts/migrations to seed DB safely and repeatably:
   - Provide seed script, batching strategy, idempotency, and rollback method.
4. Ensure “gold system rules”:
   - Balances never go negative
   - Every debit has matching ledger entry
   - Transactions are reconciled with FinaVault-style ledger references (if available)

C) TOOLING (choose best and implement)
- Prefer k6 OR Locust (pick one) + Prometheus/Grafana if possible.
- Provide complete runnable code:
  1) load_test script (scenarios + thresholds)
  2) data seeder script (200k users + related data)
  3) CI command (one-liner) to run in Replit/Linux
- Add checks:
  - functional validation assertions (status codes, schema checks)
  - business invariants (wallet balance changes consistent)
  - idempotency tests (retry-safe endpoints)
  - auth refresh tests (token expiry/renew)

D) OBSERVABILITY DURING TEST
1. Turn on metrics and logs:
   - API: request rate, latency p50/p95/p99, errors, DB query time, cache hit rate
   - Infra: CPU, memory, network, disk IO
2. Enable tracing if available (OpenTelemetry)
3. Capture top slow endpoints and top slow SQL queries

E) RESULTS + REPORT (must be very detailed)
Deliver:
1. Executive summary (pass/fail vs SLO)
2. Throughput achieved (RPS), concurrency, saturation points
3. Latency charts and percentiles by endpoint group
4. Error breakdown (4xx/5xx) with root causes
5. DB bottlenecks: slow queries + recommended indexes
6. Cache recommendations (Redis keys, TTLs, hit-rate goals)
7. Backend optimizations:
   - connection pooling
   - pagination + limits
   - background jobs for heavy tasks
   - rate limiting strategies
8. Frontend findings:
   - page load, API waterfall, heavy assets
9. Security & abuse checks under load:
   - brute-force protection impact
   - WAF/rate limit behavior
10. Action list (top 20 fixes) ranked by impact/effort
11. Retest plan after fixes

CONSTRAINTS
- Do not use real user info
- Do not disable security controls permanently (temporary test exceptions allowed only with explanation)
- Keep tests reproducible and documented
- Use batching and backoff to avoid DB overload during seeding

OUTPUT FORMAT
1) Provide folder structure
2) Provide commands to run locally and in CI
3) Provide the full code for scripts
4) Provide a final report template and example filled with plausible numbers (mark as “example”)

Now proceed:
- First, infer the likely architecture and propose the initial endpoint list.
- Then generate the complete k6/Locust code + data seeder code.
- Finally provide the report template and the expected dashboards/metrics to watch.
