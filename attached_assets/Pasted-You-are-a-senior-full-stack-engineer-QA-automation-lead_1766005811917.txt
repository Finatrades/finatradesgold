You are a senior full-stack engineer + QA automation lead.

Project: Finatrades dashboard (Replit app).
Goal: Run full configuration setting checks, add deep logging, reproduce validation errors like the toast "Minimum deposit amount is $50", and FIX them so UI + backend rules match across the platform.

PRIMARY BUG TO FIX (from screenshot):
- Card Payment modal shows "Min: $10 | Max: $10,000"
- But when user enters $1 it throws toast: "Minimum deposit amount is $50"
=> This is a rules mismatch between UI and validation layer (backend/API/config).

WHAT YOU MUST DO (in order):

1) Create a SINGLE SOURCE OF TRUTH for deposit rules
- Add a config module (e.g., /src/config/limits.ts) returning:
  - depositMinUsd (card)
  - depositMaxUsd (card)
  - other rails if present (bank transfer, crypto)
- Rules must be loaded from environment variables with safe defaults:
  - CARD_DEPOSIT_MIN_USD
  - CARD_DEPOSIT_MAX_USD
- Validate config on boot and print config to logs (without secrets).

2) Align validation across ALL layers
- Update:
  a) Frontend form validation (disable submit, inline error under Amount input)
  b) Backend/API validation (return structured error codes)
  c) Any shared service function that computes gold equivalent
- Ensure the UI displays the SAME min/max as the validation uses.
- Replace hardcoded numbers everywhere with config values.

3) Improve error handling + toast messages
- Backend should return:
  { code: "LIMIT_MIN", message: "Minimum deposit amount is $50", meta: { min: 50 } }
- Frontend should:
  - Prefer meta.min/meta.max to render message
  - Also update helper text "Min: $X | Max: $Y" dynamically from config
  - Show the error near the field + toast (toast optional)

4) Add structured logs + request tracing
- Add a requestId per deposit attempt (uuid).
- Log:
  - input amount
  - resolved config min/max
  - validation decision path
  - API response code + message
- Use structured JSON logs:
  { level, ts, requestId, userId, route, event, details }

5) Build an automated “Platform Configuration Test Suite”
Add tests that run in one command and produce logs:
- Unit tests (validation + config)
- Integration tests (API endpoints)
- E2E UI tests for the modal behavior

Minimum test cases:
A) Amount below min -> blocked on UI + backend returns LIMIT_MIN if forced
B) Amount exactly min -> allowed
C) Amount above max -> blocked + LIMIT_MAX
D) Amount non-numeric/empty -> required error
E) UI helper text always matches config (min/max)
F) Gold equivalent updates but never bypasses validation

Tooling:
- If Node/Next/React: use Vitest/Jest for unit, Supertest for API, Playwright for E2E.
- Add scripts:
  "test": run all tests
  "test:unit"
  "test:api"
  "test:e2e"
  "test:all" (unit + api + e2e)
- Configure Playwright to run headless in Replit.

6) Deliverables
- PR-style summary in comments:
  - root cause
  - files changed
  - before/after behavior
- A “Debug Panel” (hidden behind ?debug=1) that shows current config:
  - min/max values per payment rail
  - build/version
  - last 20 validation logs (client-side)

Non-negotiable:
- No hardcoded limits anywhere except defaults in config.
- UI text and backend validation must ALWAYS match.
- Keep platform fast (no extra heavy libs).
- Add clear logs so we can see exactly why a validation failed.

Start by searching the codebase for:
- "Minimum deposit amount"
- "min deposit"
- "10,000"
- "50"
- "depositMin"
Then implement the config unification + tests + logs.

When done, run tests and show output logs in the console.
